(ns canvas.sketch
  (:require [canvas.core :as core]
            [canvas.util :as u]))

(def default-frame-rate 60)

(defn frame-interval
  [frame-rate]
  (int (/ 1000 frame-rate)))

(defn make-frame
  [title [x y] [w h]]
  (let [pos #erl[:pos #erl[x y]]
        size #erl[:size #erl[w h]]
        opts #erl(pos size)
        frame (wxFrame/new (wx/new) -1 title opts)]
    frame))

(defn make-canvas
  [frame]
  (wxPanel/new frame))

(defn make-bitmap
  [canvas]
  (let [[w h] (wxWindow/getSize canvas)]
    (wxBitmap/new w h)))

(defn listen
  ([component event-type]
   (wxEvtHandler/connect component event-type))
  ([component event-type callback]
   (if (true? callback)
     (wxEvtHandler/connect component
                           event-type
                           #erl(:callback))
     (wxEvtHandler/connect component
                           event-type
                           #erl(#erl[:callback callback])))))

(defn blit [dc memory-dc]
  (let [size (wxDC/getSize memory-dc)
        origin #erl[0, 0]]
    (wxDC/blit dc origin size memory-dc origin)))

(defn render
  [state f ctx]
  (let [{canvas :canvas
         bitmap :bitmap} state
        dc        (if (= ctx :paint)
                    (wxPaintDC/new canvas)
                    (wxClientDC/new canvas))
        memory-dc (wxMemoryDC/new bitmap)]
    (try
      (binding [core/*canvas* memory-dc]
        (f)
        (blit dc memory-dc))
      (finally
        (wxMemoryDC/destroy memory-dc)
        (if (= ctx :paint)
          (wxPaintDC/destroy dc)
          (wxClientDC/destroy dc))))
    :ok))

(defn close [state]
  (erlang/halt 0))

(defn make-sketch
  [opts]
  (let [frame    (make-frame (or (:title opts) "Sketch")
                             (or (:pos opts) [50 50])
                             (or (:size opts) [500 300]))
        canvas   (make-canvas frame)
        bgcolor  (apply core/color (:bgcolor opts))
        draw-fn  (or (:draw opts) u/no-fn)
        setup-fn (or (:setup opts) u/no-fn)]

    (listen canvas :paint true)
    (wxWindow/setBackgroundColour canvas bgcolor)

    (listen frame :close_window)
    (wxWindow/show frame)

    (merge opts
           {:frame    frame
            :canvas   canvas
            :bitmap   (make-bitmap canvas)
            :setup-fn setup-fn
            :draw-fn  draw-fn})))

;; Callbacks

(defn handle_sync_event
  [wx obj state]
  (render state u/no-fn :paint)
  :ok)

(defn handle_event
  [wx state]
  (let* [#erl[:wx id obj data event] wx]
    (case* event
      #erl[:wxClose _]
        (close state)
      _
        (u/noreply state))))

(defn* handle_info
  ([:setup state]
   (render state (:setup-fn state) :draw)
   (u/noreply state))
  ([:draw state]
   (render state (:draw-fn state) :draw)
   (u/noreply state))
  ([wx state]
   (u/noreply state)))

(defn init [opts]
  (let [{frame :frame :as state} (make-sketch opts)]
    (when-let [setup (-> state :setup-fn)]
      (render state setup :draw))
    #erl[frame state]))
