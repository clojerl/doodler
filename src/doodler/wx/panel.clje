(ns doodler.wx.panel
  (:require [doodler.protocols :as p]
            [doodler.core :as core]
            [doodler.wx.gui :as gui]))

(declare init-canvas)

(deftype PanelCanvas [panel
                      width height
                      bitmap bitmap-dc gc
                      pen brush bg-brush
                      matrix
                      current-shape]
  p/ICanvas
  (canvas [this] panel)
  (width [this] width)
  (height [this] height)

  p/IBitmap
  (create-image [this w h]
    (wxBitmap/new w h))

  p/IPrimitives
  (arc [this x y w h start end]
    (let [path (wxGraphicsContext/createPath @gc)
          r (/ (math/sqrt (+ (* w w) (* h h))) 2)]
      (wxGraphicsPath/addArc path
                             x y
                             r
                             start end
                             true)
      (wxGraphicsContext/drawPath @gc path)))
  (ellipse [this x y w h]
    (wxGraphicsContext/drawEllipse
     @gc
     (- x (erlang/div w 2)) (- y (erlang/div h 2))
     w h))
  (bezier [this x1 y1 cx1 cy1 cx2 cy2 x2 y2]
    (let [path (wxGraphicsContext/createPath @gc)]
      (wxGraphicsPath/addLineToPoint path x1 y1)
      (wxGraphicsPath/addCurveToPoint path cx1 cy1 cx2 cy2 x2 y2)
      (wxGraphicsContext/drawPath @gc path)))
  (line [this x1 y1 x2 y2]
    (wxGraphicsContext/strokeLine @gc x1 y1 x2 y2))
  (point [this x y]
    (wxGraphicsContext/drawRectangle @gc x y 1 1))
  (quad [this x1 y1 x2 y2 x3 y3 x4 y4]
    (wxGraphicsContext/drawLines @gc
                                 #erl(#erl[x1 y1]
                                      #erl[x2 y2]
                                      #erl[x3 y3]
                                      #erl[x4 y4])))
  (rect [this x y w h]
    (wxGraphicsContext/drawRectangle @gc x y w h))
  (rect [this x y w h r]
    (wxGraphicsContext/drawRoundedRectangle @gc x y w h r))
  (triangle [this x1 y1 x2 y2 x3 y3]
    (wxGraphicsContext/drawLines @gc
                                 #erl(#erl[x1 y1]
                                      #erl[x2 y2]
                                      #erl[x3 y3])))

  p/IText
  (text [this s x y]
    (wxGraphicsContext/setFont @gc
                               (wxe_util/get_const :wxNORMAL_FONT)
                               #erl[0 0 0])
    (wxGraphicsContext/drawText @gc s x y))

  p/IPen
  (stroke [this color]
    (wxPen/setColour pen color)
    (wxGraphicsContext/setPen @gc pen))
  (stroke-weight [this weight]
    (wxPen/setWidth pen weight)
    (wxGraphicsContext/setPen @gc pen))
  (stroke-cap [this cap-mode]
    (wxPen/setCap pen (gui/->stroke-cap cap-mode))
    (wxGraphicsContext/setPen @gc pen))
  (stroke-join [this join-mode]
    (wxPen/setJoin pen (gui/->stroke-join join-mode))
    (wxGraphicsContext/setPen @gc pen))
  (no-stroke [this]
    (wxGraphicsContext/setPen @gc pen))

  p/IFill
  (fill [this color]
    (wxBrush/setColour brush color)
    (wxGraphicsContext/setBrush @gc brush))
  (no-fill [this]
    (wxGraphicsContext/setBrush @gc (wxBrush/new)))

  p/IBackground
  (background [this color]
    (wxBrush/setColour bg-brush color)
    (wxDC/setBackground bitmap-dc bg-brush)
    (wxDC/clear bitmap-dc))
  (background-image [this img x y]
    (wxDC/drawBitmap bitmap-dc img #erl[x y]))

  p/IEvents
  (pre-draw [this]
    (vreset! gc (wxGraphicsContext/create bitmap-dc)))
  (post-draw [this]
    (wxGraphicsContext/destroy @gc))
  (paint [this]
    (let [dc (wxPaintDC/new panel)]
      (try
        (wxDC/drawBitmap dc bitmap #erl[0 0])
        (finally
          (wxPaintDC/destroy dc)))))
  (refresh [this]
    (wxWindow/refresh panel
                      #erl(#erl[:eraseBackground false])))
  (resize [this]
    (let [bgcolor (wxBrush/getColour bg-brush)
          _ (wxMemoryDC/destroy bitmap-dc)
          _ (wxBitmap/destroy bitmap)
          canvas (init-canvas panel bgcolor)]
      (p/background canvas bgcolor)
      canvas))

  p/ITransform
  (push-matrix [this]
    (vswap! matrix conj (wxGraphicsContext/getTransform @gc)))
  (pop-matrix [this]
    (when-let [parent (first @matrix)]
      (wxGraphicsContext/setTransform @gc parent)
      (vswap! matrix pop)))
  (apply-matrix [this a b c d tx ty]
    (->> #erl(#erl[:a a] #erl[:b b]
              #erl[:c c] #erl[:d d]
              #erl[:tx tx] #erl[:yx ty])
         (wxGraphicsContext/createMatrix @gc)
         (wxGraphicsContext/concatTransform @gc)))
  (reset-matrix [this]
    (-> (wxGraphicsContext/createMatrix @gc)
        wxGraphicsMatrix/set))
  (print-matrix [this]
    (let [m (wxGraphicsContext/getTransform @gc)
          [a b c d tx ty](wxGraphicsMatrix/get m)]
      (println "Matrix:" :a a :b b :c c :d d :tx tx :ty ty)))
  (rotate [this angle]
    (wxGraphicsContext/rotate @gc angle))
  (rotate [this angle vx vy vz]
    (throw (ex-info "Not supported"
                    {:op :rotate :args [angle vx vy vz]})))
  (scale [this x-scale y-scale]
    (wxGraphicsContext/scale @gc x-scale y-scale))
  (scale [this x-scale y-scale z-scale]
    (throw (ex-info "Not supported"
                    {:op :scale :args [x-scale y-scale z-scale]})))
  (translate [this x y]
    (wxGraphicsContext/translate @gc x y))
  (translate [this x y z]
    (throw (ex-info "Not supported" {:op :translate :args [x y z]})))

  p/IShape
  (begin-shape [this]
    (let [path (wxGraphicsContext/createPath @gc)]
      (vreset! current-shape path)))
  (begin-shape [this mode]
    (throw (ex-info "Not supported" {:op :begin-shape :args [mode]})))
  (end-shape [this]
    (wxGraphicsContext/drawPath @gc @current-shape)
    (vreset! current-shape nil))
  (end-shape [this mode]
    (when (= mode :close)
      (wxGraphicsPath/closeSubpath @current-shape))
    (p/end-shape this))
  (vertex [this x y]
    (wxGraphicsPath/addLineToPoint @current-shape x y))
  (vertex [this x y z]
    (throw (ex-info "Not supported" {:op :vertex :args [x y z]})))
  (bezier-vertex [this cx1 cy1 cx2 cy2 x y]
    (wxGraphicsPath/addCurveToPoint @current-shape cx1 cy1 cx2 cy2 x y))
  (quadratic-vertex [this cx cy x3 y3]
    (wxGraphicsPath/addQuadCurveToPoint @current-shape cx cy x3 y3)))

(defn- init-canvas
  "Creates a bitmap the same size as the provided canvas.
  Returns a PanelCanvas which contains all related information to
  avoid having to fetch it while drawing.

    width         Bitmap's width
    height        Bitmap's height

    bitmap        The bitmap
    bitmap-dc     Device context for the bitmap

    bg-brush, brush, pen
                  bitmap-dc's elements"
  [panel bgcolor]
  (let [[w h]         (wxWindow/getSize panel)
        bitmap        (wxBitmap/new w h)
        bitmap-dc     (wxMemoryDC/new bitmap)
        gc            (process-val! nil)
        bg-brush      (wxDC/getBackground bitmap-dc)
        brush         (wxDC/getBrush bitmap-dc)
        pen           (wxDC/getPen bitmap-dc)
        matrix        (process-val! ())
        current-shape (process-val! nil)]
    ;; Keep the value for the background color in
    ;; the background brush. The resize event will
    ;; be triggered once on creation and its handling
    ;; will set the background color.
    (wxBrush/setColour bg-brush bgcolor)
    (->PanelCanvas panel
                   w h
                   bitmap bitmap-dc gc
                   pen brush bg-brush
                   matrix
                   current-shape)))

(defn make-canvas
  "Creates a panel canvas"
  [frame bgcolor]
  (init-canvas (wxPanel/new frame) bgcolor))
