(ns doodler.wx.opengl
  (:require [doodler.protocols :as p]
            [doodler.core :as core]
            [doodler.wx.gui :as gui]))

(declare init-panel)

(deftype OpenGLCanvas [canvas context width height]
  p/ICanvas
  (canvas [this] canvas)
  (width [this] width)
  (height [this] height)

  p/IBitmap
  (create-image [this w h]
    ;; TODO
    )

  p/IPrimitives
  (arc [this x y w h start end]
    (let [r (/ (math/sqrt (+ (* w w) (* h h))) 2)]
      (doodler_gl/arc (float x) (float y)
                      r
                      start (- end start))))
  (ellipse [this x y w h]
    (doodler_gl/circle (float x) (float y)
                       (/ w 2)))
  (line [this x1 y1 x2 y2]
    (doodler_gl/line (float x1) (float y1)
                     (float x2) (float y2)))
  (point [this x y]
    (doodler_gl/point (float x) (float y)))
  (quad [this x1 y1 x2 y2 x3 y3 x4 y4]
    (doodler_gl/quad (float x1) (float y1)
                     (float x2) (float y2)
                     (float x3) (float y3)
                     (float x4) (float y4)))
  (rect [this x y w h]
    (doodler_gl/rect (float x) (float y)
                     (float w) (float h)))
  (rect [this x y w h r]
    ;; TODO: implement rounded rectangles
    (doodler_gl/rect (float x) (float y)
                     (float w) (float h)))
  (triangle [this x1 y1 x2 y2 x3 y3]
    (doodler_gl/triangle (float x1) (float y1)
                         (float x2) (float y2)
                         (float x3) (float y3)))

  p/IText
  (text [this s x y]
    ;; TODO
    )

  p/IPen
  (stroke [this color]
    (doodler_gl/stroke color))
  (stroke-weight [this weight]
    ;; TODO
    )
  (stroke-cap [this cap-mode]
    ;; TODO
    )
  (stroke-join [this join-mode]
    ;; TODO
    )
  (no-stroke [this]
    (doodler_gl/stroke nil))

  p/IFill
  (fill [this color]
    (doodler_gl/fill color))
  (no-fill [this]
    (doodler_gl/fill nil))

  p/IBackground
  (background [this color]
    (doodler_gl/background color))
  (background-image [this img x y]
    ;; TODO
    )

  p/IEvents
  (pre-draw [this]
    (wxGLCanvas/setCurrent canvas context))
  (post-draw [this])
  (paint [this]
    (wxGLCanvas/setCurrent canvas context)
    (wxGLCanvas/swapBuffers canvas))
  (refresh [this]
    (wxWindow/refresh canvas
                      #erl(#erl[:eraseBackground false])))
  (resize [this]
    (let [[width height] (doodler_gl/resize canvas context)]
      (OpenGLCanvas. canvas context width height)))

  p/ITransform
  (push-matrix [this]
    (gl/pushMatrix))
  (pop-matrix [this]
    (gl/popMatrix))
  (rotate [this angle]
    (gl/rotatef (core/degrees angle) 0.0 0.0 1.0))
  (scale [this x-scale y-scale]
    (gl/scalef x-scale y-scale 1.0))
  (translate [this x y]
    (gl/translatef (float x) (float y) 0.0))

  p/IShape
  (begin-shape [this]
    (doodler_gl/begin_shape))
  (begin-shape [this mode]
    (doodler_gl/begin_shape mode))
  (end-shape [this]
    (doodler_gl/end_shape))
  (vertex [this x y]
    (doodler_gl/vertex (float x) (float y)))
  (vertex [this x y z]
    (doodler_gl/vertex (float x) (float y) (float z)))
  (bezier-vertex [this cx1 cy1 cx2 cy2 x y]
    (throw (ex-info "Not supported" {:op :bezier-vertex})))
  (quadratic-vertex [this cx cy x3 y3]
    (throw (ex-info "Not supported" {:op :quadratic-vertex}))))

(defn make-canvas
  "Creates an OpenGL canvas the same size as the provided canvas.
  Returns an OpenGLCanvas which contains all related information to
  avoid having to fetch it while drawing.

    canvas        OpenGL canvas
    context       OpenGL context

    width         Bitmap's width
    height        Bitmap's height"
  [frame bgcolor]
  (let [[canvas context] (doodler_gl/canvas frame bgcolor)
        [width height] (wxWindow/getSize frame)]
    (->OpenGLCanvas canvas context width height)))
