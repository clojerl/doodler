(ns doodler.core
  (:require [doodler.util :as u]
            [doodler.protocols :as p]))

(def ^:dynamic *canvas* nil)

(def ^:dynamic *sketch* nil)

(def ^:dynamic *state* nil)

(defn state
  ([] *state*)
  ([key] (get *state* key)))

(defn set-state!
  "Set sketch-specific state. May only be called once (ideally in the
  setup fn).  Subsequent calls have no effect."
  [& state-vals]
  (when-not *state*
    (let [state-map (apply hash-map state-vals)]
      (set! *state* state-map))))

(defn swap-state!
  "Set sketch-specific state. May only be called once (ideally in the
  setup fn).  Subsequent calls have no effect."
  [f & args]
  (set! *state* (apply f *state* args)))

;; Trigonometry

(def PI (math/pi))
(def HALF-PI    (/ PI 2.0))
(def THIRD-PI   (/ PI 3.0))
(def QUARTER-PI (/ PI 4.0))
(def TWO-PI     (* PI 2.0))

(def DEG-TO-RAD (/ PI 180.0))
(def RAD-TO-DEG (/ 180.0 PI))

(defn cos
  [n]
  (math/cos n))

(defn sin
  [n]
  (math/sin n))

(defn tan
  [n]
  (math/tan n))

(defn acos
  [n]
  (math/acos n))

(defn asin
  [n]
  (math/asin n))

(defn atan
  [n]
  (math/atan n))

(defn atan2
  [y x]
  (math/atan2 y x))

(defn radians
  [degrees]
  (* DEG-TO-RAD degrees))

(defn degrees
  [radians]
  (* RAD-TO-DEG radians))

;; Day & hour

(defn hour
  []
  (let* [#erl[hour _ _] (erlang/time)]
    hour))

(defn minute
  []
  (let* [#erl[_ minute _] (erlang/time)]
    minute))

(defn seconds
  []
  (let* [#erl[_ _ seconds] (erlang/time)]
    seconds))

(defn day
  []
  (let* [#erl[_ _ day] (erlang/date)]
    day))

(defn month
  []
  (let* [#erl[_ month _] (erlang/date)]
    month))

(defn year
  []
  (let* [#erl[year _ _] (erlang/date)]
    year))

;; Numbers

(defn abs
  [n]
  (erlang/abs n))

(defn ceil
  [n]
  (erlang/ceil n))

(defn exp
  [n]
  (math/exp n))

(defn floor
  [n]
  (erlang/trunc n))

(defn log
  [n]
  (math/log n))

(defn pow
  [num exponent]
  (math/pow num exponent))

(defn round
  [n]
  (erlang/round n))

(defn sq
  [n]
  (* n n))

(defn sqrt
  [n]
  (math/sqrt n))

(defn map-range
  [val low1 high1 low2 high2]
  (+ low2
     (* (- high2 low2)
        (/ (- val low1) (- high1 low1)))))

;; Color

(defn color
  ([gray]
   (color gray 255))
  ([gray alpha]
   (color gray gray gray alpha))
  ([r g b]
   (color r g b 255))
  ([r g b alpha]
   #erl[r g b alpha]))

(defn* red
  [#erl[red _ _ _]]
  red)

(defn* green
  [#erl[_ green _ _]]
  green)

(defn* blue
  [#erl[_ _ blue _]]
  blue)

(defn* alpha
  [#erl[r g b alpha]]
  alpha)

(defn* hsb-helper
  [#erl[r g b _]]
  (let* [r (/ r 255)
         g (/ g 255)
         b (/ b 255)
         max (max r g b)
         min (min r g b)
         delta (- max min)]
    #erl[r g b min max delta]))

(defn* hue
  [color]
  (let* [#erl[r g b min max delta] (hsb-helper color)]
    (if (zero? delta)
      0
      (let* [hue (case* max
                   r (/ (- g b) delta)
                   g (+ 2.0 (/ (- b r) delta))
                   b (+ 4.0 (/ (- r g) delta)))
             hue (* hue 60)
             hue (if (< hue 0) (+ hue 360) hue)]
        (round hue)))))

(defn* saturation
  [color]
  (let* [#erl[r g b min max delta] (hsb-helper color)]
    (if (zero? delta)
      0
      (/ delta
         (- 1
            (abs (- (+ min max) 1)))))))

(defn* brightness
  [color]
  (let* [#erl[_ _ _ min max _] (hsb-helper color)]
    (/ (+ min max) 2)))

;; Image

(defn background-image
  [img]
  (p/background-image *canvas* img 0 0))

(defn create-image
  [w h]
  (p/create-image *canvas* w h))

;; Stroke & fill

(defn- save-current-stroke
  [color]
  (u/swap-var! *sketch* assoc :current-stroke color))

(defn current-stroke
  []
  (:current-stroke *sketch*))

(defmacro with-stroke
  [stroke & body]
  `(let [stroke# ~stroke
         previous-stroke# (doodler.core/current-stroke)]

     (cond (sequential? stroke#) (apply doodler.core/stroke stroke#)
           true (doodler.core/stroke stroke#))

     ;;return the value from body, not from the if after it.
     (let [return-val# (do ~@body)]
       (if (nil? previous-stroke#)
         (doodler.core/no-stroke)
         (apply doodler.core/stroke previous-stroke#))
       return-val#)))

(defn stroke
  ([gray]
   (stroke gray 255))
  ([gray alpha]
   (stroke gray gray gray alpha))
  ([r g b]
   (stroke r g b 255))
  ([r g b alpha]
   (p/stroke *canvas* #erl[r g b alpha])
   (save-current-stroke (color r g b alpha))))

(defn stroke-weight
  [weight]
  (p/stroke-weight *canvas* weight))

(defn stroke-cap
  [cap-mode]
  (p/stroke-cap *canvas* cap-mode))

(defn stroke-join
  [join-mode]
  (p/stroke-join *canvas* join-mode))

(defn no-stroke
  []
  (p/no-stroke *canvas*)
  (save-current-stroke nil))

(defn background
  ([gray]
   (background gray 255))
  ([gray alpha]
   (background gray gray gray alpha))
  ([r g b]
   (background r g b 255))
  ([r g b alpha]
   (p/background *canvas* #erl[r g b alpha])))

(defn- save-current-fill
  [color]
  (u/swap-var! *sketch* assoc :current-fill color))

(defn current-fill
  []
  (:current-fill *sketch*))

(defmacro with-fill
  [fill & body]
  `(let [fill# ~fill
         previous-fill# (doodler.core/current-fill)]

     (cond (sequential? fill#) (apply doodler.core/fill fill#)
           true (doodler.core/fill fill#))

     ;;return the value from body, not from the if after it.
     (let [return-val# (do ~@body)]
       (if (nil? previous-fill#)
         (doodler.core/no-fill)
         (apply doodler.core/fill previous-fill#))
       return-val#)))

(defn fill
  ([gray]
   (fill gray 255))
  ([gray alpha]
   (fill gray gray gray alpha))
  ([r g b]
   (fill r g b 255))
  ([r g b alpha]
   (p/fill *canvas* #erl[r g b alpha])
   (save-current-fill (color r g b alpha))))

(defn no-fill
  []
  (p/no-fill *canvas*)
  (save-current-fill nil))

;; Shapes

(defn begin-shape
  "Enables the creation of complex forms. begin-shape begins recording
  vertices for a shape and end-shape stops recording. Use the mode
  keyword to specify which shape create from the provided
  vertices. With no mode specified, the shape can be any irregular
  polygon.

  The available mode keywords are :points, :lines, :triangles,
                                  :triangle-fan, :triangle-strip,
                                  :quads, :quad-strip.

  After calling the begin-shape function, a series of vertex commands
  must follow. To stop drawing the shape, call end-shape. The vertex
  function with two parameters specifies a position in 2D and the
  vertex function with three parameters specifies a position in
  3D. Each shape will be outlined with the current stroke color and
  filled with the fill color.

  Transformations such as translate, rotate, and scale do not work
  within begin-shape. It is also not possible to use other shapes,
  such as ellipse or rect within begin-shape."
  ([] (p/begin-shape *canvas*))
  ([mode] (p/begin-shape *canvas* mode)))

(defn end-shape
  "May only be called after begin-shape. When end-shape is called,
  all of image data defined since the previous call to begin-shape is
  written into the image buffer. The keyword :close may be passed to
  close the shape (to connect the beginning and the end)."
  ([] (p/end-shape *canvas*))
  ([mode] (p/end-shape *canvas* mode)))

(defn vertex
  "All shapes are constructed by connecting a series of
  vertices. vertex is used to specify the vertex coordinates for
  points, lines, triangles, quads, and polygons and is used
  exclusively within the begin-shape and end-shape fns.

  Drawing a vertex in 3D using the z parameter requires the
  :opengl renderer to be used."
  ([x y] (p/vertex *canvas* x y))
  ([x y z] (p/vertex *canvas* x y z)))

(defn bezier-vertex
  "Specifies vertex coordinates for Bezier curves. Each call to
  bezier-vertex defines the position of two control points and one
  anchor point of a Bezier curve, adding a new segment to a line or
  shape. The first time bezier-vertex is used within a begin-shape
  call, it must be prefaced with a call to vertex to set the first
  anchor point. This function must be used between begin-shape and
  end-shape and only when there is no parameter specified to
  begin-shape."
  ([cx1 cy1 cx2 cy2 x y]
   (p/bezier-vertex *canvas* cx1 cy1 cx2 cy2 x y)))

(defn quadratic-vertex
  "Specifies vertex coordinates for quadratic Bezier curves. Each call to
  quadratic-vertex defines the position of one control points and one
  anchor point of a Bezier curve, adding a new segment to a line or shape.
  The first time quadratic-vertex is used within a begin-shape call, it
  must be prefaced with a call to vertex to set the first anchor point.
  This function must be used between begin-shape and end-shape and only
  when there is no MODE parameter specified to begin-shape."
  ([cx cy x3 y3]
   (p/quadratic-vertex *canvas* cx cy x3 y3)))

;; Translation

(defn push-matrix
  []
  (p/push-matrix *canvas*))

(defn pop-matrix
  []
  (p/pop-matrix *canvas*))

(defmacro with-translation
  [translation-vector & body]
  `(let [tr# ~translation-vector]
     (doodler.core/push-matrix)
     (try
       (doodler.core/translate tr#)
       ~@body
       (finally
         (doodler.core/pop-matrix)))))

(defn translate
  ([v] (apply translate v))
  ([tx ty] (p/translate *canvas* tx ty))
  ([tx ty tz] (throw "Unsupported")))

(defmacro with-rotation
  [rotation & body]
  `(let [tr# ~rotation]
     (doodler.core/push-matrix)
     (try
       (apply doodler.core/rotate tr#)
       ~@body
       (finally
         (doodler.core/pop-matrix)))))

(defn rotate
  [angle]
  (p/rotate *canvas* angle))

(defn scale
  [x-scale y-scale]
  (p/scale *canvas* x-scale y-scale))

;; Drawing

(defn arc
  [x y w h start end]
  (p/arc *canvas* x y w h start end))

(defn ellipse
  [x y w h]
  (p/ellipse *canvas* x y w h))

(defn line
  ([p1 p2]
   (apply line (concat p1 p2)))
  ([x1 y1 x2 y2]
   (p/line *canvas* x1 y1 x2 y2)))

(defn point
  [x y]
  (p/point *canvas* x y))

(defn quad
  [x1 y1 x2 y2 x3 y3 x4 y4]
  (p/quad *canvas* x1 y1 x2 y2 x3 y3 x4 y4))

(defn rect
  ([x y w h]
   (p/rect *canvas* x y w h))
  ([x y w h r]
   (p/rect *canvas* x y w h r)))

(defn triangle
  [x1 y1 x2 y2 x3 y3]
  (p/triangle *canvas* x1 y1 x2 y2 x3 y3))

(defn bezier
  "Draws a Bezier curve on the screen. These curves are defined by a
  series of anchor and control points. The first two parameters
  specify the first anchor point and the last two parameters specify
  the other anchor point. The middle parameters specify the control
  points which define the shape of the curve."
  [x1 y1 cx1 cy1 cx2 cy2 x2 y2]
  (p/bezier *canvas* x1 y1 cx1 cy1 cx2 cy2 x2 y2))

;; Text

(defn text
  [s x y]
  (p/text *canvas* s x y))

;; Dimension

(defn width
  []
  (p/width *canvas*))

(defn height
  []
  (p/height *canvas*))

(defn frame-rate
  [new-rate]
  (let [frame-period (u/frame-period new-rate)]
    (set! *sketch*
          (assoc *sketch*
                 :frame-rate new-rate
                 :frame-period frame-period
                 :frame-delay frame-period
                 :current-frame-rate new-rate))))

(defn frame-count
  []
  (*sketch* :frame-count))

(defn target-frame-rate
  []
  (*sketch* :frame-rate))

(defn current-frame-rate
  []
  (*sketch* :current-frame-rate))

(defn millis
  []
  (- (u/time-mark) (*sketch* :epoch)))

(defn no-loop
  []
  (u/swap-var! *sketch* assoc :looping? false))

(defn looping?
  []
  (*sketch* :looping?))

(defn start-loop
  []
  (u/swap-var! *sketch* assoc :looping? true)
  (u/send-message (:pid *sketch*) :refresh))

;; Utils

(defn random
  ([max]
   (dec (rand/uniform max)))
  ([min max]
   (+ min (dec (rand/uniform max)))))

(defn exit
  []
  (erlang/halt 0))

(defmacro defsketch
  [name & opts]
  (let [opts (apply hash-map opts)]
    `(defn ~name [& opts#]
       (wx_object/start_link :doodler.sketch
                             (merge ~opts (apply hash-map opts#))
                             #erl()))))
