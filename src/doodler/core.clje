(ns doodler.core
  (:require [doodler.util :as u]))

(def ^:dynamic *canvas* nil)

(def ^:dynamic *sketch* nil)

(def ^:dynamic *state* nil)

(def ^:dynamic *internal-state* nil)

(defn state
  ([] *state*)
  ([key] (get *state* key)))

(defn set-state!
  "Set sketch-specific state. May only be called once (ideally in the
  setup fn).  Subsequent calls have no effect."
  [& state-vals]
  (when-not *state*
    (let [state-map (apply hash-map state-vals)]
      (set! *state* state-map))))

(defn swap-state!
  "Set sketch-specific state. May only be called once (ideally in the
  setup fn).  Subsequent calls have no effect."
  [f & args]
  (set! *state* (apply f *state* args)))

(defn color
  ([gray]
   (color gray 255))
  ([gray alpha]
   (color gray gray gray alpha))
  ([r g b]
   (color r g b 255))
  ([r g b alpha]
   #erl[r g b alpha]))

(defn- save-current-stroke
  "Save current stroke color vector in the internal state. It can be accessed using (current-stroke) function."
  [color]
  (set! *internal-state* (assoc *internal-state* :current-stroke color)))

(defn current-stroke
  []
  (:current-stroke *internal-state*))

(defn stroke
  [& args]
  (let [pen (wxDC/getPen *canvas*)
        color (apply color args)]
    (wxPen/setColour pen color)
    (wxDC/setPen *canvas* pen)
    (save-current-stroke color)))

(defn stroke-weight
  [weight]
  (let [pen (wxDC/getPen *canvas*)]
    (wxPen/setWidth pen weight)
    (wxDC/setPen *canvas* pen)))

(defn background
  [& args]
  (let [brush (wxDC/getBackground *canvas*)]
    (wxBrush/setColour brush (apply color args))
    (wxDC/setBackground *canvas* brush)
    (clear)))

(defn- save-current-fill
  "Save current fill color vector in the internal state. It can be accessed using (current-fill) function."
  [color]
  (set! *internal-state* (assoc *internal-state* :current-fill color)))

(defn fill
  [& args]
  (let [brush (wxDC/getBrush *canvas*)
        color (apply color args)]
    (wxBrush/setColour brush color)
    (wxDC/setBrush *canvas* brush)
    (save-current-fill color)))

(defn current-fill
  []
  (:current-fill *internal-state*))

(defn arc
  [x y w h start end]
  (wxDC/drawEllipticArc *canvas*
                        #erl[(- x (erlang/div w 2)) (- y (erlang/div h 2))]
                        #erl[w h]
                        start end))

(defn ellipse
  [x y w h]
  (wxDC/drawEllipse *canvas*
                    #erl[(- x (erlang/div w 2)) (- y (erlang/div h 2))]
                    #erl[w h]))

(defn line
  ([p1 p2] (apply line (concat p1 p2)))
  ([x1 y1 x2 y2] (wxDC/drawLine *canvas* #erl[x1 y1] #erl[x2 y2])))

(defn point
  [x y]
  (wxDC/drawPoint *canvas* #erl[x y]))

(defn random
  ([max]
   (dec (rand/uniform max)))
  ([min max]
   (+ min (dec (rand/uniform max)))))

(defn rect
  ([x y w h]
   (wxDC/drawRectangle *canvas* #erl[x y] #erl[w h]))
  ([x y w h r]
   (wxDC/drawRoundedRectangle *canvas* #erl[x y] #erl[w h] r)))

(defn text
  [s x y]
  (wxDC/drawText *canvas* s #erl[x y]))

(defn width
  []
  (erlang/element 1 (wxDC/getSize *canvas*)))

(defn height
  []
  (erlang/element 2 (wxDC/getSize *canvas*)))

(defn frame-rate
  [new-rate]
  (set! *internal-state*
        (assoc *internal-state*
               :frame-rate new-rate
               :frame-interval (u/frame-interval new-rate))))

(defn frame-count
  []
  (*sketch* :frame-count))

(defn target-frame-rate
  []
  (*internal-state* :frame-rate))

(defn current-frame-rate
  []
  (let [diff (erlang/- (u/time-mark) (:epoch *sketch*))]
    (if (pos? diff)
      (erlang/div (erlang/* (:frame-count *sketch*) 1000)
                  diff)
      0)))

(defmacro defsketch
  [name & opts]
  (let [opts (apply hash-map opts)]
    `(defn ~name []
       (wx_object/start_link :doodler.sketch ~opts #erl()))))
