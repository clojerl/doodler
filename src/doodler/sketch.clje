(ns doodler.sketch
  (:require [doodler.core :as core]
            [doodler.util :as u]))

(def default-frame-rate 60)

(defn make-frame
  [title [x y] [w h]]
  (let [pos #erl[:pos #erl[x y]]
        size #erl[:size #erl[w h]]
        opts #erl(pos size)
        frame (wxFrame/new (wx/new) -1 title opts)]
    frame))

(defn make-canvas
  [frame]
  (wxPanel/new frame))

(defn make-bitmap
  [canvas]
  (let [[w h] (wxWindow/getSize canvas)]
    (wxBitmap/new w h)))

(defn listen
  ([component event-type]
   (wxEvtHandler/connect component event-type))
  ([component event-type callback]
   (if (true? callback)
     (wxEvtHandler/connect component
                           event-type
                           #erl(:callback))
     (wxEvtHandler/connect component
                           event-type
                           #erl(#erl[:callback callback])))))

(defn blit [dc memory-dc]
  (let [size (wxDC/getSize memory-dc)
        origin #erl[0, 0]]
    (wxDC/blit dc origin size memory-dc origin)))

(defn render
  [sketch f ctx]
  (let [{canvas :canvas
         bitmap :bitmap} sketch
        dc        (if (= ctx :paint)
                    (wxPaintDC/new canvas)
                    (wxClientDC/new canvas))
        memory-dc (wxMemoryDC/new bitmap)]
    (try
      (binding [core/*canvas* memory-dc
                core/*sketch* sketch]
        (f)
        (blit dc memory-dc))
      (finally
        (wxMemoryDC/destroy memory-dc)
        (if (= ctx :paint)
          (wxPaintDC/destroy dc)
          (wxClientDC/destroy dc))))
    :ok))

(defn close [sketch]
  (erlang/halt 0))

(defn make-sketch
  [opts]
  (let [frame     (make-frame (or (:title opts) "Sketch")
                              (or (:pos opts) [50 50])
                              (or (:size opts) [500 300]))
        canvas    (make-canvas frame)
        bgcolor   (apply core/color (:bgcolor opts))
        draw-fn   (or (:draw opts) u/no-fn)
        setup-fn  (or (:setup opts) u/no-fn)
        state     (atom nil)]

    (listen canvas :paint true)
    (wxWindow/setBackgroundColour canvas bgcolor)

    ;; Handle close events
    (listen frame :close_window)
    (wxWindow/show frame)

    ;; Signal to trigger the setup phase
    (timer/send_after 0 :setup)

    (merge opts
           {:state state
            :internal-state (atom {})
            :frame frame
            :canvas canvas
            ;; Create bitmap after frame is visible to
            ;; get the right dimensions
            :bitmap (make-bitmap canvas)
            :setup-fn setup-fn
            :draw-fn draw-fn})))

(defn ensure-timer!
  "Ensure there is a timer that triggers the draw"
  [sketch]
  (let [internal-state (:internal-state sketch)
        timer-ref (:timer-ref @internal-state)]
    (when-not timer-ref
      (swap! internal-state
             assoc
             :timer-ref
             (u/create-timer default-frame-rate)))))

;; Callbacks

(defn handle_sync_event
  [wx obj sketch]
  (render sketch u/no-fn :paint)
  :ok)

(defn handle_event
  [wx sketch]
  (let* [#erl[:wx id obj data event] wx]
    (case* event
      #erl[:wxClose _]
        (close sketch)
      _
        (u/noreply sketch))))

(defn* handle_info
  ([:setup sketch]
   (render sketch (:setup-fn sketch) :draw)
   (ensure-timer! sketch)
   (u/noreply sketch))
  ([:draw sketch]
   (render sketch (:draw-fn sketch) :draw)
   (u/noreply sketch))
  ([wx sketch]
   (u/noreply sketch)))

(defn init [opts]
  (let [{frame :frame :as sketch} (make-sketch opts)]
    #erl[frame sketch]))
