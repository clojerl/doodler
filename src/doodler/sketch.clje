(ns doodler.sketch
  (:require [doodler.core :as core]
            [doodler.util :as u]))

(def SYSTEM_MENU 2048)
(def RESIZE_BORDER 64)
(def MINIMIZE_BOX 1024)
(def MAXIMIZE_BOX 512)
(def CAPTION 536870912)
(def CLIP_CHILDREN 4194304)
(def CLOSE_BOX 4096)
(def STAY_ON_TOP, 32768)

(def DEFAULT_FRAME_STYLE
  (bit-or SYSTEM_MENU
          MINIMIZE_BOX
          CLOSE_BOX
          CAPTION
          CLIP_CHILDREN))

(def feature->style {:keep-on-top [STAY_ON_TOP]
                     :resizable   [RESIZE_BORDER MAXIMIZE_BOX]})

(def default-frame-rate 60)

(defn frame-style
  [features]
  (reduce (fn [style [name active?]]
            (if (and active? (feature->style name))
              (apply bit-or style (feature->style name))
              style))
          DEFAULT_FRAME_STYLE
          features))

(defn make-frame
  [title [x y] [w h] features]
  (let [pos         #erl[:pos #erl[x y]]
        size        #erl[:size #erl[w h]]
        style       #erl[:style (frame-style features)]
        frame-opts  #erl(pos size style)
        wx          (wx/new)]
    ;; (wx/debug :driver)
    (wxFrame/new wx -1 title frame-opts)))

(defn make-canvas
  [frame]
  (wxPanel/new frame))

(defn make-bitmap
  [canvas]
  (let [[w h] (wxWindow/getSize canvas)]
    (wxBitmap/new w h)))

(defn listen
  ([component event-type & opts]
   (let [opts (apply hash-map opts)
         opts (reduce (fn [acc [k v]]
                        (if (and (= k :callback) (true? v))
                          (conj acc :callback)
                          (conj acc #erl[k v])))
                      #erl()
                      opts)]
     (wxEvtHandler/connect component event-type opts))))

(defn blit [dest source]
  (let [size (wxDC/getSize source)
        origin #erl[0 0]]
    (wxDC/blit dest origin size source origin)))

(defn refresh
  [sketch]
  (wxWindow/refresh (:canvas sketch)
                    #erl(#erl[:eraseBackground false]))
  (assoc sketch :refresh true))

(defn next-refresh
  [sketch time-mark]
  (let [interval  (-> sketch :internal-state :frame-interval)
        time-mark (+ time-mark interval)
        now       (u/time-mark)
        diff      (- time-mark now)
        delay     (max 0 diff)]
    ;; (prn :interval interval :diff diff :delay delay)
    (u/send-after delay :refresh)
    (assoc sketch :refresh false)))

(defn on-paint
  [sketch]
  (doodler.wx/batch
   #(let [bitmap (:bitmap sketch)
          dc     (wxPaintDC/new (:canvas sketch))]
      (try
        (wxDC/drawBitmap dc bitmap #erl[0 0])
        (finally
          (wxPaintDC/destroy dc)))))
  (u/send-message (:pid sketch) #erl[:draw (u/time-mark)]))

(defn on-draw
  [sketch f]
  (let [{canvas         :canvas
         bitmap-dc      :bitmap-dc
         state          :state
         internal-state :internal-state} sketch]
    (binding [core/*sketch* sketch
              core/*canvas* bitmap-dc
              core/*state*  state
              core/*internal-state* internal-state]
      (doodler.wx/batch f)
      (assoc sketch
             :state core/*state*
             :internal-state core/*internal-state*))))

(defn on-resize
  [sketch]
  (wxMemoryDC/destroy (:bitmap-dc sketch))
  (wxBitmap/destroy (:bitmap sketch))
  (let [bitmap (make-bitmap (:canvas sketch))]
    (assoc sketch
           :bitmap bitmap
           :bitmap-dc (wxMemoryDC/new bitmap))))

(def ^{:private true}
  supported-features
  #{:resizable :exit-on-close :keep-on-top
    :present :no-safe-fns :no-bind-output})

(defn make-sketch
  [opts]
  (let [middleware  (->> (:middleware opts [identity])
                         (apply comp))
        opts        (middleware opts) ;; apply middleware

        features    (let [user-features (set (:features opts))]
                        (reduce #(assoc %1 %2 (contains? user-features %2)) {}
                                supported-features))

        frame       (make-frame (or (:title opts) "Sketch")
                                (or (:pos opts) [-1 -1]) ;; default position
                                (or (:size opts) [500 300])
                                features)
        canvas      (make-canvas frame)

        bgcolor     (apply core/color (:bgcolor opts))

        draw-fn     (or (:draw opts) u/no-fn)
        setup-fn    (or (:setup opts) u/no-fn)
        on-close-fn (let [close-fn (or (:on-close opts) u/no-fn-state)]
                      (if (:exit-on-close features)
                        (fn [sketch]
                          (close-fn sketch)
                          (erlang/halt 0))
                        close-fn))

        internal-state {:frame-rate default-frame-rate
                        :frame-interval (u/frame-interval default-frame-rate)}]

    ;; Paint events need to be handled synchronously
    (listen canvas :paint :callback true)
    ;; When resizing the frame we should resize the bitmap
    (listen frame :size :skip true)
    (listen frame :close_window)

    ;; Listen to all mouse events
    (listen canvas :enter_window)
    (listen canvas :leave_window)
    (listen canvas :left_down)
    (listen canvas :middle_down)
    (listen canvas :right_down)
    (listen canvas :left_up)
    (listen canvas :middle_up)
    (listen canvas :right_up)
    (listen canvas :motion)
    (listen canvas :mousewheel)
    ;; Listen to all key events
    (listen canvas :key_down)
    (listen canvas :key_up)
    (listen canvas :char)

    ;; Set background color before showing the frame
    (wxWindow/setBackgroundColour canvas bgcolor)

    ;; Show frame, maybe in fullscreen
    (wxFrame/showFullScreen frame (:present features))
    (wxWindow/show frame)

    ;; Signal to trigger the setup phase
    (u/send-message :setup)

    (merge opts
           {:state nil
            :internal-state internal-state
            :pid (erlang/self)
            :frame frame
            :canvas canvas
            :setup-fn setup-fn
            :draw-fn draw-fn
            :on-resize on-resize
            :on-close on-close-fn}
            ;; Create bitmap after frame is visible to
            ;; get the right dimensions
           (let [bitmap (make-bitmap canvas)]
             {:bitmap    bitmap
              :bitmap-dc (wxMemoryDC/new bitmap)}))))

;; Events

(defn* event-type->mouse-event
  ([:enter_window] :mouse-entered)
  ([:leave_window] :mouse-exited)
  ([:left_down]    :mouse-pressed)
  ([:middle_down]  :mouse-pressed)
  ([:right_down]   :mouse-pressed)
  ([:left_up]      :mouse-released)
  ([:middle_up]    :mouse-released)
  ([:right_up]     :mouse-released)
  ([:motion]       :mouse-moved)
  ([:mousewheel]   :mouse-wheel))

(defn* event-type->key-event
  ([:key_down] :key-pressed)
  ([:key_up]   :key-released)
  ([:char]     :key-typed))

(defn* event->map
  ([#erl[:wxClose :close_window]]
   #erl{:event :on-close})

  ([#erl[:wxSize :size size rect]]
   #erl{:event :on-resize
        :size size})

  ([#erl[:wxFocus :set_focus window]]
   #erl{:event :focus-gained
        :window window})
  ([#erl[:wxFocus :kill_focus window]]
   #erl{:event :focus-lost
        :window window})

  ([#erl[:wxMouse type
         x y
         left middle right
         control shift alt meta
         wheel-rotation wheel-delta lines-per-action]]
   #erl{:event (event-type->mouse-event type)
        :x x :y y
        :left left :middle middle :right right
        :control control :shift shift :alt alt :meta meta
        :wheel-rotation wheel-rotation :wheel-delta wheel-delta
        :lines-per-action lines-per-action})

  ([#erl[:wxKey type
         x y
         key-code control shift alt meta
         scan-code uni-char raw-code raw-flags]]
   #erl{:event (event-type->key-event type)
        :x x :y y
        :key-code key-code
        :control control :shift shift :alt alt :meta meta
        :scan-code scan-code :uni-char uni-char
        :raw-code raw-code :raw-flags raw-flags}))

;; Callbacks

(defn handle_sync_event
  [wx obj sketch]
  (on-paint sketch)
  :ok)

(defn handle_event
  [wx sketch]
  (let* [#erl[:wx id obj data event] wx
         event (event->map event)]
    (case* (:event event)
      :on-close
      (u/stop ((sketch :on-close) sketch))
      :on-resize
      (u/noreply ((sketch :on-resize) sketch))
      event-name
      (u/noreply
       (do
         (when-let [handler (sketch event-name)]
           (handler event))
         sketch)))))

(defn* handle_info
  ([:setup sketch]
   (-> sketch
       (on-draw (:setup-fn sketch))
       refresh
       u/noreply))
  ([:refresh sketch]
   (-> sketch
       refresh
       u/noreply))
  ([#erl[:draw time-mark] sketch]
   (if (:refresh sketch)
     (-> sketch
         (on-draw (:draw-fn sketch))
         (next-refresh time-mark)
         u/noreply)
     (u/noreply sketch)))
  ([wx sketch]
   (u/noreply sketch)))

(defn init [opts]
  (let [{frame :frame :as sketch} (make-sketch opts)]
    #erl[frame sketch]))
