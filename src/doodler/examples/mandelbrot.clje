(ns doodler.examples.mandelbrot
  (:require [doodler.core :as d]
            [doodler.middlewares.state-mode :as state-mode]))

(defn points
  []
  (shuffle (for [x (range (d/width))
                 y (range (d/height))]
             #erl[x y])))

(defn ->complex
  [x y w h]
  (let [cx 0.0
        cy 0.0
        minx -2.5
        miny -2.0
        wh 4.0]
    #erl[(+ minx (* wh (/ x w)))
         (+ miny (* wh (/ y h)))]))

(defn ->color
  [n max-iters]
  (erlang/div (* 255 n) max-iters))

(defn mandelbrot [x y max-iters]
  (loop [a 0.0
         b 0.0
         n 0]
    (if (or (< max-iters n)
            (< 2 a)
            (< 2 b))
      n
      (recur (+ x (- (* a a) (* b b)))
             (+ y (* 2.0 (* a b)))
             (inc n)))))

(defn mandelbrot-point [x y w h max-iters]
  (let* [#erl[i j] (->complex x y w h)
         n         (mandelbrot i j max-iters)
         color     (->color n max-iters)]
    #erl[x y color]))

(defn on-mouse-pressed [state handler]
  (if-not (d/looping?)
    (do
      (d/start-loop)
      (d/background 0)
      {:points (points)
       :m-points nil})
    state))

(defn setup
  []
  (d/frame-rate 40)
  {:points (points)
   :m-points nil})

(defn update-state
  [{points :points :as state}]
  (if-not points
    (do
      (d/no-loop)
      state)
    (let [max-iters 100
          w         (d/width)
          h         (d/height)]
      (loop* [#erl(#erl[x y] & rest) points
              m-points #erl()
              n 0]
        (if (and (< n 500) (seq rest))
          (recur rest
                 (conj m-points (mandelbrot-point x y w h max-iters))
                 (inc n))
          {:points (seq rest)
           :m-points m-points})))))

(defn draw
  [state]
  (doseq [[x y color] (:m-points state)]
    (d/stroke color)
    (d/point x y)))

(d/defsketch sketch
  :title "Mandelbrot"
  :size [300 300]
  :setup setup
  :update update-state
  :mouse-pressed on-mouse-pressed
  :draw draw
  :bgcolor [0]
  :features [:keep-on-top]
  :middleware [state-mode/state-mode])
